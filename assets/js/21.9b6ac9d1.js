(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{224:function(e,i,l){"use strict";l.r(i);var v=l(0),t=Object(v.a)({},(function(){var e=this,i=e.$createElement,l=e._self._c||i;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h1",{attrs:{id:"typescript-高级"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#typescript-高级"}},[e._v("#")]),e._v(" typescript 高级")]),e._v(" "),l("h2",{attrs:{id:"advanced-type"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#advanced-type"}},[e._v("#")]),e._v(" Advanced Type")]),e._v(" "),l("ul",[l("li",[e._v("用户指定类型 user-defined\n"),l("ul",[l("li",[e._v("标识符 is")])])]),e._v(" "),l("li",[e._v("in 关键字")]),e._v(" "),l("li",[e._v("typeof 关键字")]),e._v(" "),l("li",[e._v("Null/undefined types\n"),l("ul",[l("li",[e._v("null undefined 是两种不同的类型")]),e._v(" "),l("li",[e._v("可选参数或者属性 --strictNullChecks 参数或者属性可以为 undefined 不能为 null")])])]),e._v(" "),l("li",[e._v("类型断言 type-assertion\n"),l("ul",[l("li",[e._v("?? = a ? '': '';")]),e._v(" "),l("li",[e._v("! = user!.id!.length; = undefined")])])]),e._v(" "),l("li",[e._v("类型别名 type-aliases\n"),l("ul",[l("li",[e._v("树形结构")])])]),e._v(" "),l("li",[e._v("interface VS Type\n"),l("ul",[l("li",[e._v("接口可以继承 Type 可以使用交叉类型实现 &")]),e._v(" "),l("li",[e._v("接口可以重复定义（相当于增加新的属性类型定义）Type 不能重复定义会报错")])])]),e._v(" "),l("li",[e._v("索引类型\n"),l("ul",[l("li",[e._v("keyof 关键字")])])]),e._v(" "),l("li",[e._v("索引类型 索引签名\n"),l("ul",[l("li",[e._v("对象键指定为string = string | number, 指定为 number, 只能为 number 类型")])])]),e._v(" "),l("li",[e._v("映射类型 mapped types\n"),l("ul",[l("li",[e._v("封装")]),e._v(" "),l("li",[e._v("类似 for...in 操作符，对一个已定义的类型遍历操作")]),e._v(" "),l("li",[e._v("不能添加新的属性定义，如果需要使用交叉类型 &")])])]),e._v(" "),l("li",[e._v("条件类型 conditional types\n"),l("ul",[l("li",[e._v("?")]),e._v(" "),l("li",[e._v("可以配合映射类型使用")])])]),e._v(" "),l("li",[e._v("推断类型 infer\n"),l("ul",[l("li",[e._v("infer 关键字配合 extends 使用")])])])]),e._v(" "),l("h2",{attrs:{id:"utility-types"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#utility-types"}},[e._v("#")]),e._v(" Utility types")]),e._v(" "),l("p",[e._v("实体类型")]),e._v(" "),l("ul",[l("li",[e._v("Partial<Type> 部分属性")]),e._v(" "),l("li",[e._v("Readonly<Type> 只读属性")]),e._v(" "),l("li",[e._v("Record<Keys, Type> 记录一组 Type 类型存在 keys 的集合当中")]),e._v(" "),l("li",[e._v("Pick<Type, Keys> 选择 Type 类型中需要存在的 keys 集合")]),e._v(" "),l("li",[e._v("Omit<Type, Keys> 反向选择 Type 类型中存在的 keys 集合")]),e._v(" "),l("li",[e._v("Exclude<Type, ExcludedUnion> 排除 Type 类型中存在 ExcludedUnion 组合类型的值")]),e._v(" "),l("li",[e._v("Extract<Type, Union> 并集")]),e._v(" "),l("li",[e._v("NonNullable<Type> 去除 Type 类型中的 null undefined")]),e._v(" "),l("li",[e._v("Parameters<Type> 构造一组元组类型使用在函数参数当中")]),e._v(" "),l("li",[e._v("ConstructorParameters<Type> 构造一组元组类型或者数组类型使用在构造函数当中")]),e._v(" "),l("li",[e._v("ReturnType<Type> 返回类型")]),e._v(" "),l("li",[e._v("InstanceType<Type> 实例类型")]),e._v(" "),l("li",[e._v("Required<Type> 与 Partial 相反")]),e._v(" "),l("li",[e._v("ThisParameterType<Type> 用于 this 作为函数参数时使用")]),e._v(" "),l("li",[e._v("OmitThisParameter<Type> 如果没有 this 的绑定，可以使用此类型用作绑定 this")]),e._v(" "),l("li",[e._v("ThisType<Type> --noImplicitThis 如果没有指定规则，必须指定 this \b强绑定")])])])}),[],!1,null,null,null);i.default=t.exports}}]);
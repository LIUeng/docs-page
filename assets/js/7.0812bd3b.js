(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{213:function(t,a,s){"use strict";s.r(a);var e=s(0),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"大o表示法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#大o表示法"}},[t._v("#")]),t._v(" 大O表示法")]),t._v(" "),s("ul",[s("li",[t._v("所有代码执行的时间T(n)与每行代码执行次数n成正比"),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("  T(n) = O(f(n))\n")])])])])]),t._v(" "),s("h2",{attrs:{id:"时间复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[t._v("#")]),t._v(" 时间复杂度")]),t._v(" "),s("p",[s("code",[t._v("大O表示的并不是程序执行的时间，而是代码执行时间随着数据增长的变化趋势，渐进时间复杂度")])]),t._v(" "),s("ol",[s("li",[t._v("只关注循环最多的那一段代码")]),t._v(" "),s("li",[t._v("加法法则：总复杂度等于量级最大的那段代码的复杂度")]),t._v(" "),s("li",[t._v("乘法法则：嵌套代码的复杂度等于嵌套内外复杂度的乘积")])]),t._v(" "),s("img",{attrs:{src:"/ent-docs/time-complex.jpg",alt:"时间复杂度图"}}),t._v(" "),s("h2",{attrs:{id:"空间复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度"}},[t._v("#")]),t._v(" 空间复杂度")]),t._v(" "),s("p",[s("code",[t._v("算法的执行时间与数据规模之间的增长关系，渐进空间复杂度")])]),t._v(" "),s("img",{attrs:{src:"/ent-docs/f(n).jpg",alt:"时间复杂度图"}}),t._v(" "),s("ul",[s("li",[t._v("最好情况时间复杂度")]),t._v(" "),s("li",[t._v("最坏情况时间复杂度")]),t._v(" "),s("li",[t._v("平均情况时间复杂度")]),t._v(" "),s("li",[t._v("均摊时间复杂度")])])])}),[],!1,null,null,null);a.default=r.exports}}]);